

88. Merge Sorted Array

You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.


Example 1:

Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].

class Solution {
    // nums1 has length of m+n, save the numbers in nums1
    // to avoid remove elements, merge from the end(large to small)
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if (n == 0) {
            return;  // no matter how many elements are there in nums1, itself is updated
        }
        if (m == 0) {
            int i = 0;
            while (n-- > 0)
                nums1[i] = nums2[i++];
            return;
        }

        int i = m - 1, j = n - 1;  // start from the end
        for (int k = m + n - 1; k >= 0; k--) {
            if (i >= 0 && j >= 0) {
                if (nums1[i] <= nums2[j]) {
                    nums1[k] = nums2[j--];
                } else {
                    nums1[k] = nums1[i--];
                }
            } else if (i >= 0){
                nums1[k] = nums1[i--];
            } else {
                nums1[k] = nums2[j--];
            }
        }

      int p1 = m-1;
            int p2 = n-1;
            int p =0;
            while(p1 >= 0 && p2 >=0){
                if(nums1[p1]>nums2[p2]){
                    nums1[p] = nums1[p1];
                    p1--;
                }else{
                    nums1[p]=nums2[p2];
                    p2--;
                }
                p--;

            }

            while(p2>=0){
                nums[p]=nums2[p2];
                p2--;
                p--;
            }

    }
}

283. Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]

class Solution {
    public void moveZeroes(int[] nums) {
        // 0 1 0 3 12
        // 1 3 12
        // solu2: met number update, for the remaining, put zero
        // corner cases: length == 1, no need to update
        int n = nums.length;
        if (n == 1)
            return;

        int k = 0;  // the idx to save non-zero elements
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                if (k != i)
                    nums[k] = nums[i];
                k++;
            }
        }

        while (k < n) {
            nums[k++] = 0;
        }

     int p = removeElement(nums,0);

            for(;p < nums.length ;p++){
                nums[p] =0;
            }
            }

            int removeElement(int[] nums,int val){
            int slow = 0;
            int fast = 0;
            while(fast <= nums.length -1){
                    if(nums[fast] != val){
                        nums[slow] = nums[fast];
                        slow++;
                    }
                    fast++;
            }
            return slow;
        }

    }
}